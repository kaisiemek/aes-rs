#[cfg(test)]
mod test {
    use crate::aes::{
        config::{AESConfig, CFBSegmentSize, OperationMode},
        constants::BLOCK_SIZE,
        key::{size::KeySize, Key},
        modes::{cbc, cfb, ctr, ecb, gcm, ofb},
    };

    #[test]
    fn test_aes128_ecb() {
        let key = get_nist_test_key_128();
        let expected_ciphertext = string_to_vec(
            concat!(
                "3AD77BB4 0D7A3660 A89ECAF3 2466EF97",
                "F5D3D585 03B9699D E785895A 96FDBAAF",
                "43B1CD7F 598ECE23 881B00E3 ED030688",
                "7B0C785E 27E8AD3F 82232071 04725DD4",
            )
            .to_string(),
        );

        run_ecb(expected_ciphertext, key);
    }

    #[test]
    fn test_aes192_ecb() {
        let key = get_nist_test_key_192();
        let expected_ciphertext = string_to_vec(
            concat!(
                "BD334F1D 6E45F25F F712A214 571FA5CC",
                "97410484 6D0AD3AD 7734ECB3 ECEE4EEF",
                "EF7AFD22 70E2E60A DCE0BA2F ACE6444E",
                "9A4B41BA 738D6C72 FB166916 03C18E0E",
            )
            .to_string(),
        );

        run_ecb(expected_ciphertext, key);
    }

    #[test]
    fn test_aes256_ecb() {
        let key = get_nist_test_key_256();
        let expected_ciphertext = string_to_vec(
            concat!(
                "F3EED1BD B5D2A03C 064B5A7E 3DB181F8",
                "591CCB10 D410ED26 DC5BA74A 31362870",
                "B6ED21B9 9CA6F4F9 F153E7B1 BEAFED1D",
                "23304B7A 39F9F3FF 067D8D8F 9E24ECC7",
            )
            .to_string(),
        );

        run_ecb(expected_ciphertext, key);
    }

    fn run_ecb(expected: Vec<u8>, key: Key) {
        let plaintext = get_nist_test_plaintext();
        let config = AESConfig::new(key, OperationMode::ECB);

        let mut ciphertext = Vec::new();
        ecb::encrypt(&mut plaintext.as_slice(), &mut ciphertext, &config).unwrap();

        let mut ciphertext_no_padding = ciphertext.clone();
        ciphertext_no_padding.truncate(ciphertext_no_padding.len() - 16);
        assert_eq!(ciphertext_no_padding, expected);

        let mut decrypted = Vec::new();
        ecb::decrypt(&mut ciphertext.as_slice(), &mut decrypted, &config).unwrap();

        assert_eq!(decrypted, plaintext);
    }

    #[test]
    fn test_aes128_cbc() {
        let key = get_nist_test_key_128();
        let expected_ciphertext = string_to_vec(
            concat!(
                "7649ABAC 8119B246 CEE98E9B 12E9197D",
                "5086CB9B 507219EE 95DB113A 917678B2",
                "73BED6B8 E3C1743B 7116E69E 22229516",
                "3FF1CAA1 681FAC09 120ECA30 7586E1A7",
            )
            .to_string(),
        );

        run_cbc(expected_ciphertext, key);
    }

    #[test]
    fn test_aes192_cbc() {
        let key = get_nist_test_key_192();
        let expected_ciphertext = string_to_vec(
            concat!(
                "4F021DB2 43BC633D 7178183A 9FA071E8",
                "B4D9ADA9 AD7DEDF4 E5E73876 3F69145A",
                "571B2420 12FB7AE0 7FA9BAAC 3DF102E0",
                "08B0E279 88598881 D920A9E6 4F5615CD",
            )
            .to_string(),
        );

        run_cbc(expected_ciphertext, key);
    }

    #[test]
    fn test_aes256_cbc() {
        let key = get_nist_test_key_256();
        let expected_ciphertext = string_to_vec(
            concat!(
                "F58C4C04 D6E5F1BA 779EABFB 5F7BFBD6",
                "9CFC4E96 7EDB808D 679F777B C6702C7D",
                "39F23369 A9D9BACF A530E263 04231461",
                "B2EB05E2 C39BE9FC DA6C1907 8C6A9D1B",
            )
            .to_string(),
        );

        run_cbc(expected_ciphertext, key);
    }

    fn run_cbc(expected: Vec<u8>, key: Key) {
        let plaintext = get_nist_test_plaintext();
        let iv = get_nist_test_iv();
        let config = AESConfig::new(key, OperationMode::CBC { iv });

        let mut ciphertext = Vec::new();
        cbc::encrypt(&mut plaintext.as_slice(), &mut ciphertext, &config).unwrap();

        let mut ciphertext_no_padding = ciphertext.clone();
        ciphertext_no_padding.truncate(ciphertext_no_padding.len() - 16);
        assert_eq!(ciphertext_no_padding, expected);

        let mut decrypted = Vec::new();
        cbc::decrypt(&mut ciphertext.as_slice(), &mut decrypted, &config).unwrap();
        assert_eq!(decrypted, plaintext);
    }

    #[test]
    fn test_aes128_ofb() {
        let key = get_nist_test_key_128();
        let expected_ciphertext = string_to_vec(
            concat!(
                "3B3FD92E B72DAD20 333449F8 E83CFB4A",
                "7789508D 16918F03 F53C52DA C54ED825",
                "9740051E 9C5FECF6 4344F7A8 2260EDCC",
                "304C6528 F659C778 66A510D9 C1D6AE5E",
            )
            .to_string(),
        );

        run_ofb(expected_ciphertext.clone(), key.clone());
        run_partial_ofb(expected_ciphertext, key);
    }

    #[test]
    fn test_aes192_ofb() {
        let key = get_nist_test_key_192();
        let expected_ciphertext = string_to_vec(
            concat!(
                "CDC80D6F DDF18CAB 34C25909 C99A4174",
                "FCC28B8D 4C63837C 09E81700 C1100401",
                "8D9A9AEA C0F6596F 559C6D4D AF59A5F2",
                "6D9F2008 57CA6C3E 9CAC524B D9ACC92A",
            )
            .to_string(),
        );

        run_ofb(expected_ciphertext.clone(), key.clone());
        run_partial_ofb(expected_ciphertext, key);
    }

    #[test]
    fn test_aes256_ofb() {
        let key = get_nist_test_key_256();
        let expected_ciphertext = string_to_vec(
            concat!(
                "DC7E84BF DA79164B 7ECD8486 985D3860",
                "4FEBDC67 40D20B3A C88F6AD8 2A4FB08D",
                "71AB47A0 86E86EED F39D1C5B BA97C408",
                "0126141D 67F37BE8 538F5A8B E740E484",
            )
            .to_string(),
        );

        run_ofb(expected_ciphertext.clone(), key.clone());
        run_partial_ofb(expected_ciphertext, key);
    }

    fn run_ofb(expected: Vec<u8>, key: Key) {
        let plaintext = get_nist_test_plaintext();
        let iv = get_nist_test_iv();
        let config = AESConfig::new(key, OperationMode::OFB { iv });

        let mut ciphertext = Vec::new();
        ofb::encrypt(&mut plaintext.as_slice(), &mut ciphertext, &config).unwrap();
        assert_eq!(ciphertext, expected);

        let mut decrypted = Vec::new();
        ofb::decrypt(&mut ciphertext.as_slice(), &mut decrypted, &config).unwrap();
        assert_eq!(decrypted, plaintext);
    }

    fn run_partial_ofb(mut expected: Vec<u8>, key: Key) {
        let mut plaintext = get_nist_test_plaintext();
        plaintext.pop();
        plaintext.pop();
        expected.pop();
        expected.pop();

        let iv = get_nist_test_iv();
        let config = AESConfig::new(key, OperationMode::OFB { iv });

        let mut ciphertext = Vec::new();
        ofb::encrypt(&mut plaintext.as_slice(), &mut ciphertext, &config).unwrap();
        assert_eq!(ciphertext, expected);

        let mut decrypted = Vec::new();
        ofb::decrypt(&mut ciphertext.as_slice(), &mut decrypted, &config).unwrap();
        assert_eq!(decrypted, plaintext);
    }

    #[test]
    fn test_aes128_cfb_128() {
        let key = get_nist_test_key_128();
        let expected_ciphertext = string_to_vec(
            concat!(
                "3B3FD92E B72DAD20 333449F8 E83CFB4A",
                "C8A64537 A0B3A93F CDE3CDAD 9F1CE58B",
                "26751F67 A3CBB140 B1808CF1 87A4F4DF",
                "C04B0535 7C5D1C0E EAC4C66F 9FF7F2E6",
            )
            .to_string(),
        );

        run_cfb_128(expected_ciphertext.clone(), key.clone());
        run_partial_cfb_128(expected_ciphertext, key);
    }

    #[test]
    fn test_aes192_cfb_128() {
        let key = get_nist_test_key_192();
        let expected_ciphertext = string_to_vec(
            concat!(
                "CDC80D6F DDF18CAB 34C25909 C99A4174",
                "67CE7F7F 81173621 961A2B70 171D3D7A",
                "2E1E8A1D D59B88B1 C8E60FED 1EFAC4C9",
                "C05F9F9C A9834FA0 42AE8FBA 584B09FF",
            )
            .to_string(),
        );

        run_cfb_128(expected_ciphertext.clone(), key.clone());
        run_partial_cfb_128(expected_ciphertext, key);
    }

    #[test]
    fn test_aes256_cfb_128() {
        let key = get_nist_test_key_256();
        let expected_ciphertext = string_to_vec(
            concat!(
                "DC7E84BF DA79164B 7ECD8486 985D3860",
                "39FFED14 3B28B1C8 32113C63 31E5407B",
                "DF101324 15E54B92 A13ED0A8 267AE2F9",
                "75A38574 1AB9CEF8 2031623D 55B1E471",
            )
            .to_string(),
        );

        run_cfb_128(expected_ciphertext.clone(), key.clone());
        run_partial_cfb_128(expected_ciphertext, key);
    }

    fn run_cfb_128(expected: Vec<u8>, key: Key) {
        let plaintext = get_nist_test_plaintext();
        let iv = get_nist_test_iv();
        let config = AESConfig::new(
            key,
            OperationMode::CFB {
                iv,
                seg_size: CFBSegmentSize::Bit128,
            },
        );

        let mut ciphertext = Vec::new();
        cfb::encrypt(&mut plaintext.as_slice(), &mut ciphertext, &config).unwrap();
        assert_eq!(ciphertext, expected);

        let mut decrypted = Vec::new();
        cfb::decrypt(&mut ciphertext.as_slice(), &mut decrypted, &config).unwrap();
        assert_eq!(decrypted, plaintext);
    }

    fn run_partial_cfb_128(mut expected: Vec<u8>, key: Key) {
        let mut plaintext = get_nist_test_plaintext();
        plaintext.pop();
        plaintext.pop();
        expected.pop();
        expected.pop();

        let iv = get_nist_test_iv();
        let config = AESConfig::new(
            key,
            OperationMode::CFB {
                iv,
                seg_size: CFBSegmentSize::Bit128,
            },
        );

        println!("{}", plaintext.as_slice().len());

        let mut ciphertext = Vec::new();
        cfb::encrypt(&mut plaintext.as_slice(), &mut ciphertext, &config).unwrap();
        assert_eq!(ciphertext, expected);

        let mut decrypted = Vec::new();
        cfb::decrypt(&mut ciphertext.as_slice(), &mut decrypted, &config).unwrap();
        assert_eq!(decrypted, plaintext);
    }

    #[test]
    fn test_aes128_cfb_8() {
        let key = get_nist_test_key_128();
        let expected_ciphertext =
            string_to_vec(concat!("3B79424C 9C0DD436 BACE9E0E D4586A4F").to_string());

        run_cfb_8(expected_ciphertext.clone(), key.clone());
        run_partial_cfb_8(expected_ciphertext, key);
    }

    #[test]
    fn test_aes192_cfb_8() {
        let key = get_nist_test_key_192();
        let expected_ciphertext =
            string_to_vec(concat!("CDA2521E F0A905CA 44CD057C BF0D47A0").to_string());

        run_cfb_8(expected_ciphertext.clone(), key.clone());
        run_partial_cfb_8(expected_ciphertext, key);
    }

    #[test]
    fn test_aes256_cfb_8() {
        let key = get_nist_test_key_256();
        let expected_ciphertext =
            string_to_vec(concat!("DC1F1A85 20A64DB5 5FCC8AC5 54844E88").to_string());

        run_cfb_8(expected_ciphertext.clone(), key.clone());
        run_partial_cfb_8(expected_ciphertext, key);
    }

    fn run_cfb_8(expected: Vec<u8>, key: Key) {
        let mut plaintext = get_nist_test_plaintext();
        plaintext.truncate(expected.len());

        let iv = get_nist_test_iv();
        let config = AESConfig::new(
            key,
            OperationMode::CFB {
                iv,
                seg_size: CFBSegmentSize::Bit8,
            },
        );

        let mut ciphertext = Vec::new();
        cfb::encrypt(&mut plaintext.as_slice(), &mut ciphertext, &config).unwrap();
        assert_eq!(ciphertext, expected);

        let mut decrypted = Vec::new();
        cfb::decrypt(&mut ciphertext.as_slice(), &mut decrypted, &config).unwrap();
        assert_eq!(decrypted, plaintext);
    }

    fn run_partial_cfb_8(mut expected: Vec<u8>, key: Key) {
        let mut plaintext = get_nist_test_plaintext();
        plaintext.truncate(expected.len() - 1);
        expected.pop();

        let iv = get_nist_test_iv();
        let config = AESConfig::new(
            key,
            OperationMode::CFB {
                iv,
                seg_size: CFBSegmentSize::Bit8,
            },
        );

        let mut ciphertext = Vec::new();
        cfb::encrypt(&mut plaintext.as_slice(), &mut ciphertext, &config).unwrap();
        assert_eq!(ciphertext, expected);

        let mut decrypted = Vec::new();
        cfb::decrypt(&mut ciphertext.as_slice(), &mut decrypted, &config).unwrap();
        assert_eq!(decrypted, plaintext);
    }

    #[test]
    fn test_aes128_ctr() {
        let key = get_nist_test_key_128();
        let expected_ciphertext = string_to_vec(
            concat!(
                "874D6191 B620E326 1BEF6864 990DB6CE",
                "9806F66B 7970FDFF 8617187B B9FFFDFF",
                "5AE4DF3E DBD5D35E 5B4F0902 0DB03EAB",
                "1E031DDA 2FBE03D1 792170A0 F3009CEE",
            )
            .to_string(),
        );

        run_ctr(expected_ciphertext.clone(), key.clone());
        run_partial_ctr(expected_ciphertext, key);
    }

    #[test]
    fn test_aes192_ctr() {
        let key = get_nist_test_key_192();
        let expected_ciphertext = string_to_vec(
            concat!(
                "1ABC9324 17521CA2 4F2B0459 FE7E6E0B",
                "090339EC 0AA6FAEF D5CCC2C6 F4CE8E94",
                "1E36B26B D1EBC670 D1BD1D66 5620ABF7",
                "4F78A7F6 D2980958 5A97DAEC 58C6B050",
            )
            .to_string(),
        );

        run_ctr(expected_ciphertext.clone(), key.clone());
        run_partial_ctr(expected_ciphertext, key);
    }

    #[test]
    fn test_aes256_ctr() {
        let key = get_nist_test_key_256();
        let expected_ciphertext = string_to_vec(
            concat!(
                "601EC313 775789A5 B7A7F504 BBF3D228",
                "F443E3CA 4D62B59A CA84E990 CACAF5C5",
                "2B0930DA A23DE94C E87017BA 2D84988D",
                "DFC9C58D B67AADA6 13C2DD08 457941A6",
            )
            .to_string(),
        );

        run_ctr(expected_ciphertext.clone(), key.clone());
        run_partial_ctr(expected_ciphertext, key);
    }

    fn run_ctr(expected: Vec<u8>, key: Key) {
        let plaintext = get_nist_test_plaintext();
        let iv = get_nist_initial_counter();
        let config = AESConfig::new(key, OperationMode::CTR { iv });

        let mut ciphertext = Vec::new();
        ctr::encrypt(&mut plaintext.as_slice(), &mut ciphertext, &config).unwrap();
        assert_eq!(ciphertext, expected);

        let mut decrypted = Vec::new();
        ctr::decrypt(&mut ciphertext.as_slice(), &mut decrypted, &config).unwrap();
        assert_eq!(decrypted, plaintext);
    }

    fn run_partial_ctr(mut expected: Vec<u8>, key: Key) {
        let mut plaintext = get_nist_test_plaintext();
        plaintext.pop();
        plaintext.pop();
        expected.pop();
        expected.pop();
        let iv = get_nist_initial_counter();
        let config = AESConfig::new(key, OperationMode::CTR { iv });

        let mut ciphertext = Vec::new();
        ctr::encrypt(&mut plaintext.as_slice(), &mut ciphertext, &config).unwrap();
        assert_eq!(ciphertext, expected);

        let mut decrypted = Vec::new();
        ctr::decrypt(&mut ciphertext.as_slice(), &mut decrypted, &config).unwrap();
        assert_eq!(decrypted, plaintext);
    }

    #[test]
    fn test_aes_gcm() {
        struct TestCase {
            plaintext: Vec<u8>,
            aad: Vec<u8>,
            expected_cipher: Vec<u8>,
            expected_tag: Vec<u8>,
            key_size: KeySize,
        }

        let test_cases = vec![
            // AES-128
            TestCase {
                plaintext: vec![],
                aad: vec![],
                expected_cipher: vec![],
                expected_tag: vec![
                    0x32, 0x47, 0x18, 0x4b, 0x3c, 0x4f, 0x69, 0xa4, 0x4d, 0xbc, 0xd2, 0x28, 0x87,
                    0xbb, 0xb4, 0x18,
                ],
                key_size: KeySize::AES128,
            },
            TestCase {
                plaintext: vec![
                    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf,
                    0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c,
                    0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09,
                    0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5,
                    0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55,
                ],
                aad: vec![],
                expected_cipher: vec![
                    0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 0x4b, 0x72, 0x21, 0xb7, 0x84,
                    0xd0, 0xd4, 0x9c, 0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0, 0x35, 0xc1,
                    0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e, 0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93,
                    0x1c, 0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05, 0x1b, 0xa3, 0x0b, 0x39,
                    0x6a, 0x0a, 0xac, 0x97, 0x3d, 0x58, 0xe0, 0x91, 0x47, 0x3f, 0x59, 0x85,
                ],
                expected_tag: vec![
                    0x4d, 0x5c, 0x2a, 0xf3, 0x27, 0xcd, 0x64, 0xa6, 0x2c, 0xf3, 0x5a, 0xbd, 0x2b,
                    0xa6, 0xfa, 0xb4,
                ],
                key_size: KeySize::AES128,
            },
            TestCase {
                plaintext: vec![],
                aad: vec![
                    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24,
                    0x66, 0xef, 0x97, 0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85,
                    0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf, 0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce,
                    0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88, 0x7b, 0x0c, 0x78, 0x5e,
                    0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4,
                ],
                expected_cipher: vec![],
                expected_tag: vec![
                    0x5f, 0x91, 0xd7, 0x71, 0x23, 0xef, 0x5e, 0xb9, 0x99, 0x79, 0x13, 0x84, 0x9b,
                    0x8d, 0xc1, 0xe9,
                ],
                key_size: KeySize::AES128,
            },
            TestCase {
                plaintext: vec![
                    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf,
                    0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c,
                    0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09,
                    0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5,
                    0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55,
                ],
                aad: vec![
                    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24,
                    0x66, 0xef, 0x97, 0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85,
                    0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf, 0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce,
                    0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88, 0x7b, 0x0c, 0x78, 0x5e,
                    0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4,
                ],
                expected_cipher: vec![
                    0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 0x4b, 0x72, 0x21, 0xb7, 0x84,
                    0xd0, 0xd4, 0x9c, 0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0, 0x35, 0xc1,
                    0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e, 0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93,
                    0x1c, 0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05, 0x1b, 0xa3, 0x0b, 0x39,
                    0x6a, 0x0a, 0xac, 0x97, 0x3d, 0x58, 0xe0, 0x91, 0x47, 0x3f, 0x59, 0x85,
                ],
                expected_tag: vec![
                    0x64, 0xc0, 0x23, 0x29, 0x04, 0xaf, 0x39, 0x8a, 0x5b, 0x67, 0xc1, 0x0b, 0x53,
                    0xa5, 0x02, 0x4d,
                ],
                key_size: KeySize::AES128,
            },
            TestCase {
                plaintext: vec![
                    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf,
                    0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c,
                    0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09,
                    0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5,
                    0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39,
                ],
                aad: vec![
                    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24,
                    0x66, 0xef, 0x97, 0xf5, 0xd3, 0xd5, 0x85,
                ],
                expected_cipher: vec![
                    0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 0x4b, 0x72, 0x21, 0xb7, 0x84,
                    0xd0, 0xd4, 0x9c, 0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0, 0x35, 0xc1,
                    0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e, 0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93,
                    0x1c, 0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05, 0x1b, 0xa3, 0x0b, 0x39,
                    0x6a, 0x0a, 0xac, 0x97, 0x3d, 0x58, 0xe0, 0x91,
                ],
                expected_tag: vec![
                    0xf0, 0x7c, 0x25, 0x28, 0xee, 0xa2, 0xfc, 0xa1, 0x21, 0x1f, 0x90, 0x5e, 0x1b,
                    0x6a, 0x88, 0x1b,
                ],
                key_size: KeySize::AES128,
            },
            TestCase {
                plaintext: vec![
                    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf,
                    0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c,
                    0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09,
                    0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5,
                    0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39,
                ],
                aad: vec![
                    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24,
                    0x66, 0xef, 0x97, 0xf5, 0xd3, 0xd5, 0x85,
                ],
                expected_cipher: vec![
                    0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 0x4b, 0x72, 0x21, 0xb7, 0x84,
                    0xd0, 0xd4, 0x9c, 0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0, 0x35, 0xc1,
                    0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e, 0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93,
                    0x1c, 0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05, 0x1b, 0xa3, 0x0b, 0x39,
                    0x6a, 0x0a, 0xac, 0x97, 0x3d, 0x58, 0xe0, 0x91,
                ],
                expected_tag: vec![
                    0xf0, 0x7c, 0x25, 0x28, 0xee, 0xa2, 0xfc, 0xa1, 0x21, 0x1f, 0x90, 0x5e,
                ],
                key_size: KeySize::AES128,
            },
            // AES-192
            TestCase {
                plaintext: vec![],
                aad: vec![],
                expected_cipher: vec![],
                expected_tag: vec![
                    0xc8, 0x35, 0xaa, 0x88, 0xae, 0xbb, 0xc9, 0x4f, 0x5a, 0x02, 0xe1, 0x79, 0xfd,
                    0xcf, 0xc3, 0xe4,
                ],
                key_size: KeySize::AES192,
            },
            TestCase {
                plaintext: vec![
                    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf,
                    0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c,
                    0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09,
                    0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5,
                    0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55,
                ],
                aad: vec![],
                expected_cipher: vec![
                    0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41, 0xeb, 0x06, 0xfa, 0xc4, 0x87,
                    0x2a, 0x27, 0x57, 0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84, 0x62, 0x85,
                    0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c, 0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5,
                    0x25, 0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47, 0x18, 0xe2, 0x44, 0x8b,
                    0x2f, 0xe3, 0x24, 0xd9, 0xcc, 0xda, 0x27, 0x10, 0xac, 0xad, 0xe2, 0x56,
                ],
                expected_tag: vec![
                    0x99, 0x24, 0xa7, 0xc8, 0x58, 0x73, 0x36, 0xbf, 0xb1, 0x18, 0x02, 0x4d, 0xb8,
                    0x67, 0x4a, 0x14,
                ],
                key_size: KeySize::AES192,
            },
            TestCase {
                plaintext: vec![],
                aad: vec![
                    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24,
                    0x66, 0xef, 0x97, 0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85,
                    0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf, 0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce,
                    0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88, 0x7b, 0x0c, 0x78, 0x5e,
                    0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4,
                ],
                expected_cipher: vec![],
                expected_tag: vec![
                    0x02, 0xcc, 0x77, 0x3b, 0xc9, 0x19, 0xf4, 0xe1, 0xc5, 0xe9, 0xc5, 0x43, 0x13,
                    0xbf, 0xac, 0xe0,
                ],
                key_size: KeySize::AES192,
            },
            TestCase {
                plaintext: vec![
                    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf,
                    0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c,
                    0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09,
                    0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5,
                    0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55,
                ],
                aad: vec![
                    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24,
                    0x66, 0xef, 0x97, 0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85,
                    0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf, 0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce,
                    0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88, 0x7b, 0x0c, 0x78, 0x5e,
                    0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4,
                ],
                expected_cipher: vec![
                    0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41, 0xeb, 0x06, 0xfa, 0xc4, 0x87,
                    0x2a, 0x27, 0x57, 0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84, 0x62, 0x85,
                    0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c, 0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5,
                    0x25, 0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47, 0x18, 0xe2, 0x44, 0x8b,
                    0x2f, 0xe3, 0x24, 0xd9, 0xcc, 0xda, 0x27, 0x10, 0xac, 0xad, 0xe2, 0x56,
                ],
                expected_tag: vec![
                    0x3b, 0x91, 0x53, 0xb4, 0xe7, 0x31, 0x8a, 0x5f, 0x3b, 0xbe, 0xac, 0x10, 0x8f,
                    0x8a, 0x8e, 0xdb,
                ],
                key_size: KeySize::AES192,
            },
            TestCase {
                plaintext: vec![
                    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf,
                    0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c,
                    0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09,
                    0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5,
                    0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39,
                ],
                aad: vec![
                    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24,
                    0x66, 0xef, 0x97, 0xf5, 0xd3, 0xd5, 0x85,
                ],
                expected_cipher: vec![
                    0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41, 0xeb, 0x06, 0xfa, 0xc4, 0x87,
                    0x2a, 0x27, 0x57, 0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84, 0x62, 0x85,
                    0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c, 0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5,
                    0x25, 0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47, 0x18, 0xe2, 0x44, 0x8b,
                    0x2f, 0xe3, 0x24, 0xd9, 0xcc, 0xda, 0x27, 0x10,
                ],
                expected_tag: vec![
                    0x93, 0xea, 0x28, 0xc6, 0x59, 0xe2, 0x69, 0x90, 0x2a, 0x80, 0xac, 0xd2, 0x08,
                    0xe7, 0xfc, 0x80,
                ],
                key_size: KeySize::AES192,
            },
            TestCase {
                plaintext: vec![
                    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf,
                    0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c,
                    0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09,
                    0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5,
                    0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39,
                ],
                aad: vec![
                    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24,
                    0x66, 0xef, 0x97, 0xf5, 0xd3, 0xd5, 0x85,
                ],
                expected_cipher: vec![
                    0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41, 0xeb, 0x06, 0xfa, 0xc4, 0x87,
                    0x2a, 0x27, 0x57, 0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84, 0x62, 0x85,
                    0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c, 0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5,
                    0x25, 0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47, 0x18, 0xe2, 0x44, 0x8b,
                    0x2f, 0xe3, 0x24, 0xd9, 0xcc, 0xda, 0x27, 0x10,
                ],
                expected_tag: vec![
                    0x93, 0xea, 0x28, 0xc6, 0x59, 0xe2, 0x69, 0x90, 0x2a, 0x80, 0xac, 0xd2,
                ],
                key_size: KeySize::AES192,
            },
            // AES-256
            TestCase {
                plaintext: vec![],
                aad: vec![],
                expected_cipher: vec![],
                expected_tag: vec![
                    0xfd, 0x2c, 0xaa, 0x16, 0xa5, 0x83, 0x2e, 0x76, 0xaa, 0x13, 0x2c, 0x14, 0x53,
                    0xee, 0xda, 0x7e,
                ],
                key_size: KeySize::AES256,
            },
            TestCase {
                plaintext: vec![
                    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf,
                    0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c,
                    0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09,
                    0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5,
                    0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55,
                ],
                aad: vec![],
                expected_cipher: vec![
                    0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 0xf4, 0x7f, 0x37, 0xa3, 0x2a,
                    0x84, 0x42, 0x7d, 0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9, 0x75, 0x98,
                    0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa, 0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb,
                    0x3d, 0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38, 0xc5, 0xf6, 0x1e, 0x63,
                    0x93, 0xba, 0x7a, 0x0a, 0xbc, 0xc9, 0xf6, 0x62, 0x89, 0x80, 0x15, 0xad,
                ],
                expected_tag: vec![
                    0xb0, 0x94, 0xda, 0xc5, 0xd9, 0x34, 0x71, 0xbd, 0xec, 0x1a, 0x50, 0x22, 0x70,
                    0xe3, 0xcc, 0x6c,
                ],
                key_size: KeySize::AES256,
            },
            TestCase {
                plaintext: vec![],
                aad: vec![
                    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24,
                    0x66, 0xef, 0x97, 0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85,
                    0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf, 0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce,
                    0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88, 0x7b, 0x0c, 0x78, 0x5e,
                    0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4,
                ],
                expected_cipher: vec![],
                expected_tag: vec![
                    0xde, 0x34, 0xb6, 0xdc, 0xd4, 0xce, 0xe2, 0xfd, 0xbe, 0xc3, 0xce, 0xa0, 0x1a,
                    0xf1, 0xee, 0x44,
                ],
                key_size: KeySize::AES256,
            },
            TestCase {
                plaintext: vec![
                    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf,
                    0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c,
                    0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09,
                    0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5,
                    0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55,
                ],
                aad: vec![
                    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24,
                    0x66, 0xef, 0x97, 0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85,
                    0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf, 0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce,
                    0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88, 0x7b, 0x0c, 0x78, 0x5e,
                    0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4,
                ],
                expected_cipher: vec![
                    0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 0xf4, 0x7f, 0x37, 0xa3, 0x2a,
                    0x84, 0x42, 0x7d, 0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9, 0x75, 0x98,
                    0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa, 0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb,
                    0x3d, 0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38, 0xc5, 0xf6, 0x1e, 0x63,
                    0x93, 0xba, 0x7a, 0x0a, 0xbc, 0xc9, 0xf6, 0x62, 0x89, 0x80, 0x15, 0xad,
                ],
                expected_tag: vec![
                    0xc0, 0x6d, 0x76, 0xf3, 0x19, 0x30, 0xfe, 0xf3, 0x7a, 0xca, 0xe2, 0x3e, 0xd4,
                    0x65, 0xae, 0x62,
                ],
                key_size: KeySize::AES256,
            },
            TestCase {
                plaintext: vec![
                    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf,
                    0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c,
                    0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09,
                    0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5,
                    0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39,
                ],
                aad: vec![
                    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24,
                    0x66, 0xef, 0x97, 0xf5, 0xd3, 0xd5, 0x85,
                ],
                expected_cipher: vec![
                    0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 0xf4, 0x7f, 0x37, 0xa3, 0x2a,
                    0x84, 0x42, 0x7d, 0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9, 0x75, 0x98,
                    0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa, 0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb,
                    0x3d, 0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38, 0xc5, 0xf6, 0x1e, 0x63,
                    0x93, 0xba, 0x7a, 0x0a, 0xbc, 0xc9, 0xf6, 0x62,
                ],
                expected_tag: vec![
                    0xe0, 0x97, 0x19, 0x5f, 0x45, 0x32, 0xda, 0x89, 0x5f, 0xb9, 0x17, 0xa5, 0xa5,
                    0x5c, 0x6a, 0xa0,
                ],
                key_size: KeySize::AES256,
            },
            TestCase {
                plaintext: vec![
                    0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf,
                    0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c,
                    0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09,
                    0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5,
                    0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39,
                ],
                aad: vec![
                    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24,
                    0x66, 0xef, 0x97, 0xf5, 0xd3, 0xd5, 0x85,
                ],
                expected_cipher: vec![
                    0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 0xf4, 0x7f, 0x37, 0xa3, 0x2a,
                    0x84, 0x42, 0x7d, 0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9, 0x75, 0x98,
                    0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa, 0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb,
                    0x3d, 0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38, 0xc5, 0xf6, 0x1e, 0x63,
                    0x93, 0xba, 0x7a, 0x0a, 0xbc, 0xc9, 0xf6, 0x62,
                ],
                expected_tag: vec![
                    0xe0, 0x97, 0x19, 0x5f, 0x45, 0x32, 0xda, 0x89, 0x5f, 0xb9, 0x17, 0xa5,
                ],
                key_size: KeySize::AES256,
            },
        ];

        for test_case in test_cases {
            run_gcm(
                &test_case.plaintext,
                &test_case.expected_cipher,
                &test_case.aad,
                &test_case.expected_tag,
                test_case.key_size,
            )
        }
    }

    fn run_gcm(
        mut plaintext: &[u8],
        expected_cipher: &[u8],
        aad: &[u8],
        expected_tag: &[u8],
        key_size: KeySize,
    ) {
        let key = match key_size {
            KeySize::AES128 => Key::from([
                0xFE, 0xFF, 0xE9, 0x92, 0x86, 0x65, 0x73, 0x1C, 0x6D, 0x6A, 0x8F, 0x94, 0x67, 0x30,
                0x83, 0x08,
            ]),
            KeySize::AES192 => Key::from([
                0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30,
                0x83, 0x08, 0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
            ]),
            KeySize::AES256 => Key::from([
                0xFE, 0xFF, 0xE9, 0x92, 0x86, 0x65, 0x73, 0x1C, 0x6D, 0x6A, 0x8F, 0x94, 0x67, 0x30,
                0x83, 0x08, 0xFE, 0xFF, 0xE9, 0x92, 0x86, 0x65, 0x73, 0x1C, 0x6D, 0x6A, 0x8F, 0x94,
                0x67, 0x30, 0x83, 0x08,
            ]),
        };

        let iv = vec![
            0xCA, 0xFE, 0xBA, 0xBE, 0xFA, 0xCE, 0xDB, 0xAD, 0xDE, 0xCA, 0xF8, 0x88,
        ];

        let mut ciphertext = vec![];
        let mut decrypted = vec![];
        let initial_plaintext = plaintext;

        let (_, tag) =
            gcm::authenticated_encrypt(&mut plaintext, &mut ciphertext, &key, &iv, aad).unwrap();
        assert_eq!(ciphertext, expected_cipher);

        let mut tag_data = tag.bytes().to_vec();
        tag_data.truncate(expected_tag.len());
        assert_eq!(tag_data, expected_tag);

        gcm::authenticated_decrypt(
            &mut ciphertext.as_slice(),
            &mut decrypted,
            &key,
            &iv,
            aad,
            tag,
        )
        .expect("decryption could not be authenticated");
        assert_eq!(decrypted, initial_plaintext);

        if ciphertext.len() < 6 {
            return;
        }
        // tamper with the ciphertext
        ciphertext[5] = !ciphertext[5];

        gcm::authenticated_decrypt(
            &mut ciphertext.as_slice(),
            &mut decrypted,
            &key,
            &iv,
            aad,
            tag,
        )
        .expect_err(
            "the ciphertext has been tampered with, the authentication tags should not match up.",
        );
    }

    fn get_nist_test_plaintext() -> Vec<u8> {
        string_to_vec(
            concat!(
                "6BC1BEE2 2E409F96 E93D7E11 7393172A",
                "AE2D8A57 1E03AC9C 9EB76FAC 45AF8E51",
                "30C81C46 A35CE411 E5FBC119 1A0A52EF",
                "F69F2445 DF4F9B17 AD2B417B E66C3710"
            )
            .to_string(),
        )
    }

    fn get_nist_test_iv() -> [u8; BLOCK_SIZE] {
        string_to_vec(concat!("00010203 04050607 08090A0B 0C0D0E0F").to_string())
            .try_into()
            .unwrap()
    }

    fn get_nist_initial_counter() -> [u8; BLOCK_SIZE] {
        string_to_vec("F0F1F2F3 F4F5F6F7 F8F9FAFB FCFDFEFF".to_string())
            .try_into()
            .unwrap()
    }

    fn get_nist_test_key_128() -> Key {
        let key_data = string_to_vec(concat!("2B7E1516 28AED2A6 ABF71588 09CF4F3C").to_string());
        key_data.as_slice().try_into().unwrap()
    }

    fn get_nist_test_key_192() -> Key {
        let key_data = string_to_vec(
            concat!("8E73B0F7 DA0E6452 C810F32B 809079E5 62F8EAD2 522C6B7B").to_string(),
        );
        key_data.as_slice().try_into().unwrap()
    }

    fn get_nist_test_key_256() -> Key {
        let key_data = string_to_vec(
            concat!(
                "603DEB10 15CA71BE 2B73AEF0 857D7781",
                "1F352C07 3B6108D7 2D9810A3 0914DFF4"
            )
            .to_string(),
        );
        key_data.as_slice().try_into().unwrap()
    }

    fn string_to_vec(mut str: String) -> Vec<u8> {
        str = str.replace(' ', "");
        str = str.replace('\n', "");
        (0..str.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&str[i..i + 2], 16).unwrap())
            .collect()
    }
}
