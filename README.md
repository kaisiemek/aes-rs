# Advanced Encryption Standard Rust Implementation

![GitHub Actions Badge](https://github.com/kaisiemek/aes-rs/actions/workflows/rust.yml/badge.svg)

This is an **educational** project that aims to implement the NIST Advanced Encryption Standard (AES) or Rijndael block cipher in pure Rust with as few dependencies as possible. **Security is in no way guaranteed!**

## Supported Modes

- **Electronic Cookbook (ECB)** mode, simply encrypt each block with Rijndael (never use for more than one block, incredibly insecure). Padding is required.
- **Cipher Block Chaining (CBC)** mode, the result of the previous block's encryption is fed back to the current block and XOR'd before getting encrypted. Padding is required.
- **Cipher Feedback (CFB)** mode, implements a stream cipher using Rijndael to create the encryption stream bytes. Uses the previous ciphertext block to create the input block for the Rinjdael block encryption operation. Additionally, a segment size can be chosen to modify how many bits of plaintext are processed at a time. Currently supported: 8-bit and 128-bit variants.
- **Output Feedback (OFB)** mode. Implements a stream cipher similar to CFB. The output of the previous blocks Rijndael block encryption operation is used as the input for the next block encryption operation. XOR'ing the output with the plaintext block results in the corresponding ciphertext block.
- **Counter (CTR)** mode. Is also used to implement a stream cipher. A unique counter is chosen for each block and used as input for the block encryption operation. The output is XOR'd with the plaintext block to obtain the ciphertext block.

## Encryption Mode Architecture

Each mode of operation allows the iterative encryption of a current block (128 bits) or segment.
For each block there are a few variables that have the same meaning across all modes of operation, with sight differences. These variable names have been inspired by the block cipher techniques document by the National Institute of Standards and Technology (NIST). Some of these block variables may be omitted when redundant, for example if the ciphertext block is just the output block, the extra step of assigning the output block is skipped.

- **plaintext_block** this block represents the current plaintext input/output for the encryption/decryption process respectively, in case of non-padded modes of operation like CTR the last output block may be a partial block (fewer than 128 bits). The last input block may always be a partial block but might get padded.
- **ciphertext_block** analogous to the plaintext block, output/input block for the encryption/decryption process.
- **input_block** the block that will be fed into the block cipher (AES-128, -192 or -256 depending on the key length), this may either be the encryption or decryption process. Please note that operation modes that use the Rijndael block cipher to generate a stream cipher like CTR will not use the decryption process whatsoever and instead XOR the output of the block cipher with the plaintext/ciphertext blocks to generate the corresponding ciphertext/plaintext blocks.
- **output_block** the block that is generated by feeding the input block in the block cipher.

## Resources

- [the updated NIST AES spec](https://csrc.nist.gov/pubs/fips/197/final)
- [test vectors and values by NIST used for validation](https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/example-values)
- [NIST block operation modes description](https://csrc.nist.gov/projects/block-cipher-techniques/bcm/current-modes)
- [Christof Paar's Understanding Cryptography (German version: Kryptographie Verst√§ndlich)](https://www.crypto-textbook.com)
- [Christ Paar's lectures on YouTube (German, English version available)](https://www.youtube.com/watch?v=NHuibtoL_qk)
- [reference implementation used to generate validation data](https://www.cryptool.org/en/cto/aes-step-by-step)

## TODO

- CFB: more chunk sizes (multiples of 8), (CFB-1?)
- GCM (and CCM?) mode
- (XTR mode?)
- (Key generation?)
